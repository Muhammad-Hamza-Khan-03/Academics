
#include<iostream>
using namespace std;
class Heap
{
	int maxSize, currSize;
	int* h=0;
public:
	Heap(int n=10)
	{
		maxSize = n;
		currSize = 0;
		h = new int[maxSize];
	}
	~Heap()
	{
		if (h != 0)
		{
			delete[] h;
			h = 0;
		}
	}
	
	void heapify(int *h,int i,int currSize)
	{
		int left, right, largest;
			left = 2 * i, right = 2 * i + 1, largest = i;
			if (left <= currSize && h[left] > h[largest])
				largest = left;
			if (right <= currSize && h[right] > h[largest])
				largest = right;
			if (largest==i)
				break;
			else
			{
				swap(h[i],h[largest]);
				i = largest;
				heapify(h,i,size);
			}
		}
	}
	
	void buildHeap(int* a, int n)
	{
		if (h != 0)
		{
			delete[] h;
			h = 0;
		}
		h = new int[n + 1];
		maxSize = n;
		for (int i = 0; i < n; i++)
		{
			h[i + 1] = a[i];
		}
		currSize = n;
		for (int i = currSize/2; i >= 1; i--)
		{
			heapify(i);
		}
	}
	void display()
	{
		for (int i = 0; i < currSize; i++)
		{
			cout<<h[i + 1]<<" ";
		}
	}
	void removeMax(int & a)
	{
		a = h[1];
		h[1] = h[currSize];
		currSize--;
		heapify(1);
	}
	
};
void heapSort(int* a, int n)
{
	Heap mh;
	mh.buildHeap(a, n);
	for (int i = n - 1; i >= 0; i--)
	{
		mh.removeMax(a[i]);
	}
}
int main()
{
	int arr[] = { 1, 3, 5, 4, 6, 13, 10, 9, 8, 15, 17 };
	Heap mh;
	mh.buildHeap(arr, 11);
	mh.display();
	cout << endl;
	int a []= { 6, 3, 5, 4, 2, 1 };
	for (int i = 0; i < 6; i++)
	{
		cout << a[i] << " ";
	}
	cout << endl;
	heapSort(a, 6);
	for (int i = 0; i < 6; i++)
	{
		cout << a[i] << " ";
	}
	system("pause");
	return 0;
}

#include <iostream>
#include <assert.h>
#include <stdio.h>
#include <fstream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
template <class v>
struct HashItem
{
	template <class h>
	friend class HashMap;
	enum class Status
	{
		EMPTY,
		DELETED,
		OCCUPIED
	};
	int key;
	v value;
	Status status;
	HashItem(int _key = 0, v _value = v(), Status _status = Status::EMPTY)
	{
		key = _key;
		value = _value;
		status = _status;
	}
};
template <class v>
class HashMap
{
protected:
	HashItem<v>* hashArray;
	int capacity;
	int currentElements;
	virtual int getNextCandidateIndex(int key, int i) const
	{
		return (key + i) % capacity;
	}
	float loadFactor() { return (float)currentElements / (float)capacity; }
	float nextLoadFactor() { return (float)(currentElements + 1) / (float)capacity; }
	void doubleCapacity() // Doubling the capacity and rehashing the array
	{
		int oldCapacity = capacity;
		capacity = 2 * capacity;
		HashItem<v>* tempHashArray = new HashItem<v>[capacity];
		for (int i = 0; i < oldCapacity; i++)
		{
			if (hashArray[i].status == HashItem<v>::Status::OCCUPIED)
			{
				int j = 0;
				int index = getNextCandidateIndex(hashArray[i].key, j);
				while (tempHashArray[index].status == HashItem<v>::Status::OCCUPIED && j < capacity)
					index = getNextCandidateIndex(hashArray[i].key, ++j);
				if (j >= capacity)
					continue;
				tempHashArray[index].key = hashArray[i].key;
				tempHashArray[index].value = hashArray[i].value;
				tempHashArray[index].status = hashArray[i].status;
			}
		}
		delete[] hashArray;
		this->hashArray = tempHashArray;
	}
public:
	HashMap()
	{
		capacity = 10;
		hashArray = new HashItem<v>[capacity];
		currentElements = 0;
	}
	HashMap(int const _capacity)
	{
		assert(_capacity > 0);
		capacity = _capacity;
		hashArray = new HashItem<v>[capacity];
		currentElements = 0;
	}
	void insert(int const key, v const value)
	{
		if (nextLoadFactor() >= 0.75)
			doubleCapacity();
		int i = 0;
		int index = getNextCandidateIndex(key, i);
		while (hashArray[index].status == HashItem<v>::Status::OCCUPIED && i < capacity)
			index = getNextCandidateIndex(key, ++i);
		if (i >= capacity)
			return;
		hashArray[index].key = key;
		hashArray[index].value = value;
		hashArray[index].status = HashItem<v>::Status::OCCUPIED;
		currentElements++;
	}
	void display()
	{
		cout << "Index\t| Key\tValue\n";
		for (int i = 0; i < capacity; i++)
		{
			cout << i << "\t| ";
			if (hashArray[i].status == HashItem<v>::Status::EMPTY)
				cout << 'E';
			else if (hashArray[i].status == HashItem<v>::Status::OCCUPIED)
				cout << hashArray[i].key << '\t' << hashArray[i].value;
			else if (hashArray[i].status == HashItem<v>::Status::DELETED)
				cout << 'D';
			cout << endl;
		}
	}
	bool deleteKey(int const key) const
	{
		v* toBeDeleted = get(key);
		if (toBeDeleted == nullptr)
			return false;
		int i = 0;
		int index = getNextCandidateIndex(key, i);
		while (hashArray[index].key != key && hashArray[index].status != HashItem<v>::Status::EMPTY && i < capacity)
			index = getNextCandidateIndex(key, ++i);
		if (hashArray[index].key == key)
			hashArray[index].status = HashItem<v>::Status::EMPTY;
		return true;
	}
	v* get(int const key) const
	{
		int i = 0;
		int index = getNextCandidateIndex(key, i);
		while (hashArray[index].key != key && hashArray[index].status != HashItem<v>::Status::EMPTY && i < capacity)
			index = getNextCandidateIndex(key, ++i);
		v* result = nullptr;
		if (hashArray[index].key == key)
			result = &(hashArray[index].value);
		return result;
	}
	~HashMap()
	{
		delete[] hashArray;
	}
};
